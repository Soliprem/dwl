diff --git a/config.h b/config.h
index 56428ab..452e88c 100644
--- a/config.h
+++ b/config.h
@@ -10,11 +10,14 @@ static const float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
 
 static const Rule rules[] = {
-	/* app_id     title       tags mask     isfloating   monitor */
+	/* app_id     title       tags mask     isfloating   isterminal    noswallow    monitor */
 	/* examples:
-	{ "Gimp",     NULL,       0,            1,           -1 },
+	RULE(.id = "Gimp", .isfloating = 1, .noswallow = 1)
 	*/
-	{ "firefox",  NULL,       1 << 8,       0,           -1 },
+	RULE(.id = "brave", .tags = 1 << 8),
+#if SWALLOW_PATCH
+	RULE(.id = "foot", .isterminal = 1)
+#endif
 };
 
 /* layout(s) */
@@ -99,8 +102,8 @@ static const double accel_speed = 0.0;
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
 /* commands */
-static const char *termcmd[] = { "alacritty", NULL };
-static const char *menucmd[] = { "bemenu-run", NULL };
+static const char *termcmd[] = { "foot", NULL };
+static const char *menucmd[] = { "rofi", "-show", "run", NULL };
 
 static const Key keys[] = {
 	/* Note that Shift changes certain key codes: c -> C, 2 -> at, etc. */
@@ -144,6 +147,11 @@ static const Key keys[] = {
 #define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
 	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
 	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
+
+#if SHIFTVIEW_PATCH
+	{ MODKEY,                    XKB_KEY_semicolon,          shiftview,      { .i = -1 } },
+	{ MODKEY,                    XKB_KEY_apostrophe,         shiftview,      { .i = 1 } },
+#endif
 };
 
 static const Button buttons[] = {
diff --git a/dwl.c b/dwl.c
index 30fd2ac..d5a2fb2 100644
--- a/dwl.c
+++ b/dwl.c
@@ -59,9 +59,12 @@
 
 /* macros */
 #define CLEANMASK(mask) (mask & ~WLR_MODIFIER_CAPS)
-#define VISIBLEON(C, M) ((M) && (C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
+#define VISIBLEONTAG(C, T) ((C)->tags & T)
+#define VISIBLEONMON(C, M) ((M) && (C)->mon == (M) && VISIBLEONTAG(C, (M)->tagset[(M)->seltags]))
 #define TAGMASK ((1 << LENGTH(tags)) - 1)
 #define LISTEN(E, L, H) wl_signal_add((E), ((L)->notify = (H), (L)))
+#define RULE(...) \
+	{ .monitor = -1, __VA_ARGS__ }
 
 /* enums */
 enum { CurNormal,
@@ -102,7 +105,8 @@ typedef struct {
 } Button;
 
 typedef struct Monitor Monitor;
-typedef struct {
+typedef struct Client Client;
+struct Client {
 	/* Must keep these three elements in this order */
 	unsigned int type;	 /* XDGShell or X11* */
 	struct wlr_box geom; /* layout-relative, includes border */
@@ -131,9 +135,14 @@ typedef struct {
 	int bw;
 	unsigned int tags;
 	int isfloating, isurgent;
+#if SWALLOW_PATCH
+	int isterminal, noswallow;
+	pid_t pid;
+	Client *swallowing, *swallowedby;
+#endif
 	uint32_t resize; /* configure serial of a pending resize */
 	int isfullscreen;
-} Client;
+};
 
 typedef struct {
 	uint32_t singular_anchor;
@@ -195,7 +204,6 @@ struct Monitor {
 	unsigned int tagset[2];
 	double mfact;
 	int nmaster;
-	int un_map; /* If a map/unmap happened on this monitor, then this should be true */
 };
 
 typedef struct {
@@ -212,6 +220,9 @@ typedef struct {
 	const char *title;
 	unsigned int tags;
 	int isfloating;
+#if SWALLOW_PATCH
+	int isterminal, noswallow;
+#endif
 	int monitor;
 } Rule;
 
@@ -388,7 +399,6 @@ static Atom netatom[NetLast];
 
 /* attempt to encapsulate suck into one file */
 #include "client.h"
-
 #include "patches/include.c"
 
 /* compile-time check if all tags fit into an unsigned int bit array. */
@@ -490,12 +500,20 @@ void applyrules(Client *c) {
 	for (r = rules; r < END(rules); r++) {
 		if ((!r->title || strstr(title, r->title)) && (!r->id || strstr(appid, r->id))) {
 			c->isfloating = r->isfloating;
+#if SWALLOW_PATCH
+			c->isterminal = r->isterminal;
+			c->noswallow = r->noswallow;
+#endif
 			newtags |= r->tags;
 			i = 0;
 			wl_list_for_each(m, &mons, link) if (r->monitor == i++)
 				mon = m;
 		}
 	}
+#if ALWAYSCENTER_PATCH
+	c->geom.x = (mon->w.width - c->geom.width) / 2 + mon->m.x;
+	c->geom.y = (mon->w.height - c->geom.height) / 2 + mon->m.y;
+#endif
 	wlr_scene_node_reparent(c->scene, layers[c->isfloating ? LyrFloat : LyrTile]);
 	setmon(c, mon, newtags);
 }
@@ -503,7 +521,7 @@ void applyrules(Client *c) {
 void arrange(Monitor *m) {
 	Client *c;
 	wl_list_for_each(c, &clients, link)
-		wlr_scene_node_set_enabled(c->scene, VISIBLEON(c, c->mon));
+		wlr_scene_node_set_enabled(c->scene, VISIBLEONMON(c, c->mon));
 
 	if (m->lt[m->sellt]->arrange)
 		m->lt[m->sellt]->arrange(m);
@@ -958,7 +976,10 @@ void createnotify(struct wl_listener *listener, void *data) {
 	/* Allocate a Client for this surface */
 	c = xdg_surface->data = ecalloc(1, sizeof(*c));
 	c->surface.xdg = xdg_surface;
-	c->bw = borderpx;
+
+#if SWALLOW_PATCH
+	wl_client_get_credentials(c->surface.xdg->client->client, &c->pid, NULL, NULL);
+#endif
 
 	LISTEN(&xdg_surface->surface->events.commit, &c->commit, commitnotify);
 	LISTEN(&xdg_surface->events.map, &c->map, mapnotify);
@@ -1167,14 +1188,14 @@ void focusstack(const Arg *arg) {
 		wl_list_for_each(c, &sel->link, link) {
 			if (&c->link == &clients)
 				continue; /* wrap past the sentinel node */
-			if (VISIBLEON(c, selmon))
+			if (VISIBLEONMON(c, selmon))
 				break; /* found it */
 		}
 	} else {
 		wl_list_for_each_reverse(c, &sel->link, link) {
 			if (&c->link == &clients)
 				continue; /* wrap past the sentinel node */
-			if (VISIBLEON(c, selmon))
+			if (VISIBLEONMON(c, selmon))
 				break; /* found it */
 		}
 	}
@@ -1185,7 +1206,7 @@ void focusstack(const Arg *arg) {
 Client *
 focustop(Monitor *m) {
 	Client *c;
-	wl_list_for_each(c, &fstack, flink) if (VISIBLEON(c, m)) return c;
+	wl_list_for_each(c, &fstack, flink) if (VISIBLEONMON(c, m)) return c;
 	return NULL;
 }
 
@@ -1360,14 +1381,28 @@ void mapnotify(struct wl_listener *listener, void *data) {
 	if (c->isfullscreen)
 		setfullscreen(c, 1);
 
-	c->mon->un_map = 1;
+#if SWALLOW_PATCH
+	if (!c->noswallow) {
+		Client *p = termforwin(c);
+		if (p) {
+			c->swallowedby = p;
+			p->swallowing = c;
+			wl_list_remove(&c->link);
+			wl_list_remove(&c->flink);
+			swallow(c, p);
+			wl_list_remove(&p->link);
+			wl_list_remove(&p->flink);
+		}
+		arrange(c->mon);
+	}
+#endif
 }
 
 void monocle(Monitor *m) {
 	Client *c;
 
 	wl_list_for_each(c, &clients, link) {
-		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
+		if (!VISIBLEONMON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
 		resize(c, m->w.x, m->w.y, m->w.width, m->w.height, 0);
 	}
@@ -1618,22 +1653,12 @@ void rendermon(struct wl_listener *listener, void *data) {
 
 	/* Render if no XDG clients have an outstanding resize and are visible on
 	 * this monitor. */
-	/* Checking m->un_map for every client is not optimal but works */
-	wl_list_for_each(c, &clients, link) {
-		if ((c->resize && m->un_map) || (c->type == XDGShell && (c->surface.xdg->pending.geometry.width !=
-																	 c->surface.xdg->current.geometry.width ||
-																 c->surface.xdg->pending.geometry.height !=
-																	 c->surface.xdg->current.geometry.height))) {
-			/* Lie */
-			wlr_surface_send_frame_done(client_surface(c), &now);
-			skip = 1;
-		}
-	}
+	wl_list_for_each(c, &clients, link)
+		skip = skip || (!c->isfloating && c->resize);
 	if (!skip && !wlr_scene_output_commit(m->scene_output))
 		return;
 	/* Let clients know a frame has been rendered */
 	wlr_scene_output_send_frame_done(m->scene_output, &now);
-	m->un_map = 0;
 }
 
 void requeststartdrag(struct wl_listener *listener, void *data) {
@@ -1652,6 +1677,25 @@ void resize(Client *c, int x, int y, int w, int h, int interact) {
 	c->geom.y = y;
 	c->geom.width = w;
 	c->geom.height = h;
+	c->bw = borderpx;
+
+#if NOBORDER_PATCH
+	unsigned int n = 0;
+	Client *tmp;
+	wl_list_for_each(tmp, &clients, link) {
+		if (VISIBLEONMON(tmp, c->mon) && !tmp->isfloating)
+			n++;
+	}
+
+	if ((n == 1 || &monocle == c->mon->lt[c->mon->sellt]->arrange) &&
+		!c->isfullscreen &&
+		!c->isfloating &&
+		c->mon->lt[c->mon->sellt]->arrange) {
+		c->geom.width += c->bw * 2;
+		c->geom.height += c->bw * 2;
+		c->bw = 0;
+	}
+#endif
 	applybounds(c, bbox);
 
 	/* Update scene-graph, including borders */
@@ -1728,7 +1772,7 @@ void run(char *startup_cmd) {
 Client *
 selclient(void) {
 	Client *c = wl_container_of(fstack.next, c, flink);
-	if (wl_list_empty(&fstack) || !VISIBLEON(c, selmon))
+	if (wl_list_empty(&fstack) || !VISIBLEONMON(c, selmon))
 		return NULL;
 	return c;
 }
@@ -2067,8 +2111,10 @@ void tile(Monitor *m) {
 	unsigned int i, n = 0, h, mw, my, ty;
 	Client *c;
 
-	wl_list_for_each(c, &clients, link) if (VISIBLEON(c, m) && !c->isfloating && !c->isfullscreen)
-		n++;
+	wl_list_for_each(c, &clients, link) {
+		if (VISIBLEONMON(c, m) && !c->isfloating && !c->isfullscreen)
+			n++;
+	}
 	if (n == 0)
 		return;
 
@@ -2078,7 +2124,7 @@ void tile(Monitor *m) {
 		mw = m->w.width;
 	i = my = ty = 0;
 	wl_list_for_each(c, &clients, link) {
-		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
+		if (!VISIBLEONMON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
 		if (i < m->nmaster) {
 			h = (m->w.height - my) / (MIN(n, m->nmaster) - i);
@@ -2150,8 +2196,18 @@ void unmapnotify(struct wl_listener *listener, void *data) {
 		grabc = NULL;
 	}
 
-	if (c->mon)
-		c->mon->un_map = 1;
+#if SWALLOW_PATCH
+	if (c->swallowing) {
+		c->swallowing->swallowedby = NULL;
+		c->swallowing = NULL;
+	}
+
+	if (c->swallowedby) {
+		swallow(c->swallowedby, c);
+		c->swallowedby->swallowing = NULL;
+		c->swallowedby = NULL;
+	}
+#endif
 
 	if (client_is_unmanaged(c)) {
 		wlr_scene_node_destroy(c->scene);
@@ -2279,7 +2335,7 @@ void zoom(const Arg *arg) {
 
 	/* Search for the first tiled window that is not sel, marking sel as
 	 * NULL if we pass it along the way */
-	wl_list_for_each(c, &clients, link) if (VISIBLEON(c, selmon) && !c->isfloating) {
+	wl_list_for_each(c, &clients, link) if (VISIBLEONMON(c, selmon) && !c->isfloating) {
 		if (c != sel)
 			break;
 		sel = NULL;
@@ -2326,7 +2382,6 @@ void createnotifyx11(struct wl_listener *listener, void *data) {
 	c = xwayland_surface->data = ecalloc(1, sizeof(*c));
 	c->surface.xwayland = xwayland_surface;
 	c->type = xwayland_surface->override_redirect ? X11Unmanaged : X11Managed;
-	c->bw = borderpx;
 
 	/* Listen to the various events it can emit */
 	LISTEN(&xwayland_surface->events.map, &c->map, mapnotify);
diff --git a/patches.h b/patches.h
index 2574204..ef044f9 100644
--- a/patches.h
+++ b/patches.h
@@ -13,3 +13,19 @@
 /* Hide the mouse cursor if it isn't being used after a specified timeout.
  */
 #define UNCLUTTER_PATCH 1
+
+/* Hide terminal-emulators when they launch a GUI application.
+ */
+#define SWALLOW_PATCH 1
+
+/* Always center floating windows.
+ */
+#define ALWAYSCENTER_PATCH 1
+
+/* Add keybindings for left and right circular shift through tags.
+ */
+#define SHIFTVIEW_PATCH 1
+
+/* Hide the border when only one window is visible.
+ */
+#define NOBORDER_PATCH 1
diff --git a/patches/include.c b/patches/include.c
index 83ee3d6..cdef51c 100644
--- a/patches/include.c
+++ b/patches/include.c
@@ -1,3 +1,11 @@
+#if SWALLOW_PATCH
+#include "swallow.c"
+#endif
+
 #if UNCLUTTER_PATCH
 #include "unclutter.c"
 #endif
+
+#if SHIFTVIEW_PATCH
+#include "shiftview.c"
+#endif
diff --git a/patches/include.h b/patches/include.h
index 4a597a6..b8c28f6 100644
--- a/patches/include.h
+++ b/patches/include.h
@@ -1,3 +1,11 @@
+#if SWALLOW_PATCH
+#include "swallow.h"
+#endif
+
 #if UNCLUTTER_PATCH
 #include "unclutter.h"
 #endif
+
+#if SHIFTVIEW_PATCH
+#include "shiftview.h"
+#endif
diff --git a/patches/shiftview.c b/patches/shiftview.c
new file mode 100644
index 0000000..99b6ca0
--- /dev/null
+++ b/patches/shiftview.c
@@ -0,0 +1,34 @@
+/* "arg->i" stores the number of tags to shift right (positive value)
+ *          or left (negative value)
+ */
+void shiftview(const Arg *arg) {
+	Arg a;
+	Client *c;
+	size_t ntags = LENGTH(tags);
+	bool visible = false;
+	int i = arg->i;
+	int count = 0;
+	int nextseltags, curseltags = selmon->tagset[selmon->seltags];
+
+	do {
+		if (i > 0)	// left circular shift
+			nextseltags = (curseltags << i) | (curseltags >> (ntags - i));
+		else  // right circular shift
+			nextseltags = curseltags >> (-i) | (curseltags << (ntags + i));
+
+		// Check if the tag is visible
+		wl_list_for_each(c, &clients, link) {
+			if (nextseltags & c->tags) {
+				visible = true;
+				break;
+			}
+		}
+
+		i += arg->i;
+	} while (!visible && ++count <= ntags);
+
+	if (count <= ntags) {
+		a.i = nextseltags;
+		view(&a);
+	}
+}
diff --git a/patches/shiftview.h b/patches/shiftview.h
new file mode 100644
index 0000000..f9bfbd3
--- /dev/null
+++ b/patches/shiftview.h
@@ -0,0 +1 @@
+void shiftview(const Arg *arg);
diff --git a/patches/swallow.c b/patches/swallow.c
new file mode 100644
index 0000000..631c989
--- /dev/null
+++ b/patches/swallow.c
@@ -0,0 +1,46 @@
+pid_t getparentprocess(pid_t p) {
+	unsigned int v = 0;
+
+	FILE *f;
+	char buf[256];
+	snprintf(buf, sizeof(buf) - 1, "/proc/%u/stat", (unsigned)p);
+
+	if (!(f = fopen(buf, "r")))
+		return 0;
+
+	fscanf(f, "%*u %*s %*c %u", &v);
+	fclose(f);
+
+	return (pid_t)v;
+}
+
+int isdescprocess(pid_t p, pid_t c) {
+	while (p != c && c != 0)
+		c = getparentprocess(c);
+
+	return (int)c;
+}
+
+Client *
+termforwin(Client *w) {
+	Client *c;
+
+	if (!w->pid || w->isterminal || w->noswallow)
+		return NULL;
+
+	wl_list_for_each(c, &clients, link) if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid)) return c;
+
+	return NULL;
+}
+
+void swallow(Client *c, Client *w) {
+	c->bw = w->bw;
+	c->isfloating = w->isfloating;
+	c->isurgent = w->isurgent;
+	c->isfullscreen = w->isfullscreen;
+	resize(c, w->geom.x, w->geom.y, w->geom.width, w->geom.height, 0);
+	wl_list_insert(&w->link, &c->link);
+	wl_list_insert(&w->flink, &c->flink);
+	wlr_scene_node_set_enabled(w->scene, 0);
+	wlr_scene_node_set_enabled(c->scene, 1);
+}
diff --git a/patches/swallow.h b/patches/swallow.h
new file mode 100644
index 0000000..cc56b38
--- /dev/null
+++ b/patches/swallow.h
@@ -0,0 +1,4 @@
+static pid_t getparentprocess(pid_t p);
+static int isdescprocess(pid_t p, pid_t c);
+static Client *termforwin(Client *w);
+static void swallow(Client *c, Client *w);
